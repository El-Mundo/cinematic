package GIS.JAVA;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;

import GIS.JAVA.MapPlot.GeoPerson;

//WARNING: Depends on "GIS/source/map_plots.csv" generated by GeographyMovement.java
public class ClusteredGeographyMovements {
	static HashMap<Integer, GeoPerson> mapPlots;
	private static final String  SRC = "GIS/source/map_plots.csv";
	private static final String CLU_MOV_EDGES_TAR = "GIS/statistics/edges-clustered_movements.csv", CLU_MOV_NODES_TAR = "GIS/statistics/nodes-clustered_movements.csv";
	//Works similarly to the one in GeographyMovement.java
	private static final boolean APPLY_INERT = true;
	//Enable this to count the movements between two locations in all years together as weight
	private static final boolean CLUSTER_YEARS = true;
	
	public static void main(String[] args) {
		try {
			initAllMapPlots();
			generateClusteredGeographyMovementCSV();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	private static void generateClusteredGeographyMovementCSV() throws IOException {
		//Store geographical movement formatted as a String like "START-DESTINATION:STAR_YEAR-DEST_YEAR" and 
		//assign it with the count of such movements in this map
		HashMap<String, Integer> clusterAndCountMap = new HashMap<String, Integer>();

		for (GeoPerson p : mapPlots.values()) {
			if(!APPLY_INERT) {
				int year = p.debutYear;
				String next[] = p.appearances.get(year).getMainCategory();
				String prev[] = next;
				int prevYear = year;
				year++;

				if(year > p.lastAppearance) {
					//If this person only appeared in one year, this person cannot make any movements, so skip
					continue;
				}

				for (; year <= p.lastAppearance; year++) {
					next = p.appearances.get(year).getMainCategory();
					if(next.length <= 0) {
						//If this person did not appear in this year, skip this year and keep the previous location and year
						continue;
					}
					ClusteredMovement mov = new ClusteredMovement(prev, next, prevYear, year);
					String tag = mov.toString();
					clusterAndCountMap.put(tag, clusterAndCountMap.getOrDefault(tag, 0) + 1);
					prev = next;
					prevYear = year;
				}
			} else {
				//This is different from the "prev[]" above, as
				//it only stores the locations that are kept after applying inert filter
				ArrayList<String> prevLocs = new ArrayList<String>();

				int year = p.debutYear;
				String next[] = p.appearances.get(year).getMainCategory();
				int prevYear = year;
				year++;

				for (; year <= p.lastAppearance; year++) {
					next = p.appearances.get(year).getMainCategory();

					if(next.length <= 0) {
						//If this person did not appear in this year, skip this year and keep the previous location and year
						continue;
					}else{
						//Locations with inert decides the locations that are kept after applying inert filter
						ArrayList<String> locationsWithInert = new ArrayList<String>();
						for (String string : next) {
							if(prevLocs.contains(string)) {
								locationsWithInert.add(string);
							}
						}

						if(locationsWithInert.size() <= 0) {
							//Force to update location because no inert location can be found
							//In this case the new locations can be directly added to locationsWithInert
							for (String string : next) {
								locationsWithInert.add(string);
							}
						}

						//Write to map
						ClusteredMovement mov = new ClusteredMovement(prevLocs.toArray(
							new String[prevLocs.size()]), locationsWithInert.toArray(new String[locationsWithInert.size()]),
							prevYear, year);
						String tag = mov.toString();
						clusterAndCountMap.put(tag, clusterAndCountMap.getOrDefault(tag, 0) + 1);

						//Update previvous locations
						prevLocs.clear();
						for(String loc : locationsWithInert) {
							prevLocs.add(loc);
						}
						prevYear = year;
					}
				}
			}
		}

		//Convert the map to a list of ClusteredMovement
		ArrayList<ClusteredMovement> clusteredMovements = new ArrayList<ClusteredMovement>();
		//Use this to store the nodes information of each cluster
		HashMap<String, Integer> clusteredRegions = new HashMap<String, Integer>();
		int id = 0;

		for (String tag : clusterAndCountMap.keySet()) {
			ClusteredMovement mov = new ClusteredMovement(tag);
			mov.count = clusterAndCountMap.get(tag);
			if(!clusteredRegions.containsKey(mov.startCat)) {
				clusteredRegions.put(mov.startCat, id);
				id++;
			}
			if(!clusteredRegions.containsKey(mov.destCat)) {
				clusteredRegions.put(mov.destCat, id);
				id++;
			}
			clusteredMovements.add(mov);
		}

		//Write edges to file
		if(!CLUSTER_YEARS) {
			BufferedWriter writer = new BufferedWriter(new FileWriter(CLU_MOV_EDGES_TAR));
			writer.write("Source,Target,Weight,SourceName,TargetName,StartYear,EndYear\n");
			for (ClusteredMovement mov : clusteredMovements) {
				writer.write(clusteredRegions.get(mov.startCat) + ","
				+ clusteredRegions.get(mov.destCat) + "," + mov.count + ",\"" +
				mov.startCat + "\",\"" + mov.destCat + "\"," +
				mov.startYear + "," + mov.destYear + "\n");
			}
			writer.close();
		} else {
			//This map ignores year ranges and use String like "START-DESTINATION" as key
			HashMap<String, Integer> clusterAndCountMap2 = new HashMap<String, Integer>();
			for (ClusteredMovement mov : clusteredMovements) {
				//Merge all movements between two regions in different years together
				String tag = mov.startCat + "-" + mov.destCat;
				clusterAndCountMap2.put(tag, clusterAndCountMap2.getOrDefault(tag, 0) + mov.count);
			}
			BufferedWriter writer = new BufferedWriter(new FileWriter(CLU_MOV_EDGES_TAR.substring(0, CLU_MOV_EDGES_TAR.length() - 4) + "(all_years).csv"));
			writer.write("Source,Target,Weight,SourceName,TargetName\n");
			for (String tag : clusterAndCountMap2.keySet()) {
				String[] regions = tag.split("-");
				writer.write(clusteredRegions.get(regions[0]) + ","
				+ clusteredRegions.get(regions[1]) + "," + clusterAndCountMap2.get(tag) + ",\"" +
				regions[0] + "\",\"" + regions[1] + "\"\n");
			}
			writer.close();
		}

		//Write nodes info to file
		BufferedWriter writer2 = new BufferedWriter(new FileWriter(CLU_MOV_NODES_TAR));
		writer2.write("Id,Name\n");
		for (String region : clusteredRegions.keySet()) {
			writer2.write(clusteredRegions.get(region) + "," + region + "\n");
		}
		writer2.close();
	}

	private static void initAllMapPlots() throws IOException {
		mapPlots = new HashMap<Integer, GeoPerson>();
		File nodeFile = new File(SRC);
		int lineNum = GeographyMovement.getFileLineNumber(nodeFile);
		BufferedReader reader = new BufferedReader(new FileReader(nodeFile));
		String line = reader.readLine();
		int n = 0;
		while((line = reader.readLine()) != null) {
			System.out.println("Initing map plots: " + (n) + "/" + lineNum);
			n++;

			String[] lineSplit = line.split(",", -1);
			String name = lineSplit[1];
			int id = Integer.parseInt(lineSplit[0]);
			int debutYear = Integer.parseInt(lineSplit[2]);
			int endYear = Integer.parseInt(lineSplit[3]);
			boolean fromPrivateStudio = lineSplit[4].equalsIgnoreCase("true");
			mapPlots.put(id, new GeoPerson(id, name, debutYear, endYear, fromPrivateStudio, lineSplit[5]));

			for(int col=6; col<24; col++) {
				int year = col + 1943;
				String app = lineSplit[col];
				if(!app.isBlank()) {
					String[] apps = app.split(" & ");
					for (String string : apps) {
						int count = Integer.parseInt(string.substring(string.lastIndexOf("[") + 1, string.lastIndexOf("]")));
						String cat = string.substring(0, string.lastIndexOf("[")).trim();
						mapPlots.get(id).addAffiliationCategory(cat, year, count);
					}
				}
			}
		}
		reader.close();
	}
}

class ClusteredMovement {
	String startCat, destCat;
	int startYear, destYear;
	//Only used in writing to file
	int count = -1;
	
	public ClusteredMovement(String startCat, String destCat, int startYear, int destYear) {
		this.startCat = startCat;
		this.destCat = destCat;
		this.destYear = destYear;
		this.startYear = startYear;
	}

	public ClusteredMovement(String[] prevYearCats, String[] nextYearCats, int startYear, int destYear) {
		//Convert the two String arrays to two String formatted like "LOCATION 1 & LOCATION 2 & LOCATION 3..."
		String prev = "", next = "";
		for (String string : prevYearCats) {
			prev += string + " & ";
		}
		for (String string : nextYearCats) {
			next += string + " & ";
		}
		if(prevYearCats.length > 0) prev = prev.substring(0, prev.length() - 3);
		if(nextYearCats.length > 0) next = next.substring(0, next.length() - 3);

		this.startCat = prev;
		this.destCat = next;
		this.startYear = startYear;
		this.destYear = destYear;
	}

	public ClusteredMovement(String formattedString) {
		String[] split = formattedString.split(":");
		String[] locs = split[0].split("-");
		String[] years = split[1].split("-");
		this.startCat = locs[0];
		this.destCat = locs[1];
		this.startYear = Integer.parseInt(years[0]);
		this.destYear = Integer.parseInt(years[1]);
	}
	
	@Override
	public String toString() {
		return startCat + "-" + destCat + ":" + startYear + "-" + destYear;
	}
}